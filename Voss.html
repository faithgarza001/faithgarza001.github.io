<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced 3D Drink Commercial</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
    
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(45deg, #0f0f23, #1a1a2e, #16213e);
      color: #fff;
      font-family: 'Inter', sans-serif;
    }
    
    .ui-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 100;
    }
    
    .ui-element {
      pointer-events: auto;
    }
    
    #info {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: white;
      text-shadow: 0 0 10px rgba(0,255,255,0.5);
      font-size: 1rem;
      font-weight: 300;
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    
    .control-panel {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
    }
    
    .control-btn {
      padding: 12px 20px;
      background: rgba(0,255,255,0.1);
      border: 1px solid rgba(0,255,255,0.3);
      color: white;
      border-radius: 25px;
      cursor: pointer;
      font-weight: 600;
      backdrop-filter: blur(15px);
      transition: all 0.3s ease;
      text-transform: uppercase;
      font-size: 0.8rem;
      letter-spacing: 1px;
    }
    
    .control-btn:hover {
      background: rgba(0,255,255,0.2);
      border-color: rgba(0,255,255,0.6);
      box-shadow: 0 0 20px rgba(0,255,255,0.3);
      transform: translateY(-2px);
    }
    
    .control-btn:active {
      transform: translateY(0);
    }
    
    #audio-prompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 30px 50px;
      border-radius: 15px;
      cursor: pointer;
      font-size: 1.25rem;
      font-weight: 600;
      z-index: 1000;
      transition: all 0.5s ease;
      border: 2px solid rgba(0,255,255,0.5);
      backdrop-filter: blur(20px);
    }
    
    #audio-prompt:hover {
      background: rgba(0,255,255,0.1);
      transform: translate(-50%, -50%) scale(1.05);
    }
    
    .stats-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      font-family: monospace;
      font-size: 0.8rem;
      border: 1px solid rgba(0,255,255,0.3);
      backdrop-filter: blur(10px);
    }
    
    .particle-count {
      color: #00ffff;
      font-weight: bold;
    }
    
    .logo {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(45deg, #00ffff, #ffffff, #00ffff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(0,255,255,0.5);
      animation: logoGlow 3s ease-in-out infinite;
    }
    
    @keyframes logoGlow {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.5); }
    }
    
    .fps-counter {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #00ff00;
      font-family: monospace;
      font-size: 1rem;
    }
  </style>
</head>
<body>
  <div class="ui-overlay">
    <div id="audio-prompt" class="ui-element">üéµ Click to start immersive experience</div>
    
    <div class="control-panel">
      <button id="splash-button" class="control-btn ui-element">üí• Mega Splash</button>
      <button id="bubble-burst" class="control-btn ui-element">ü´ß Bubble Burst</button>
      <button id="color-shift" class="control-btn ui-element">üåà Color Shift</button>
      <button id="freeze-time" class="control-btn ui-element">‚è∏Ô∏è Freeze Time</button>
    </div>
    
    <div class="stats-panel ui-element">
      <div>Bubbles: <span class="particle-count" id="bubble-count">0</span></div>
      <div>Particles: <span class="particle-count" id="particle-count">0</span></div>
      <div>Effects: <span class="particle-count" id="effect-count">0</span></div>
    </div>
    
    <div class="fps-counter ui-element" id="fps-counter">FPS: 60</div>
    
    <div class="logo">V√òSS</div>
    
    <div id="info">
      üñ±Ô∏è Drag to orbit ‚Ä¢ üì± Touch to explore ‚Ä¢ üéÆ Use controls for effects
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
  let scene, camera, renderer, can, mirrorCan, ambientLight, pointLight, spotLight;
      const bubbles = [], splashes = [], trails = [], raindrops = [];
      let isDragging = false, previousMousePosition = { x: 0, y: 0 };
      let audioContextStarted = false, timeScale = 1, colorShift = 0;
      let mouseX = 0, mouseY = 0;
      const DAMPING = 0.08;
      let frameCount = 0, lastTime = performance.now();

      // UI Elements
      const splashButton = document.getElementById('splash-button');
      const bubbleBurst = document.getElementById('bubble-burst');
      const colorShiftBtn = document.getElementById('color-shift');
      const freezeTimeBtn = document.getElementById('freeze-time');
      const audioPrompt = document.getElementById('audio-prompt');
      const fpsCounter = document.getElementById('fps-counter');

      // Enhanced Tone.js setup
      const reverb = new Tone.Reverb(4).toDestination();
      const delay = new Tone.PingPongDelay("8n", 0.3).connect(reverb);
      
      const splashSynth = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.8 },
      }).connect(delay);
      
      const bubbleSynth = new Tone.Synth({
        oscillator: { type: 'sine' },
        envelope: { attack: 0.1, decay: 0.2, sustain: 0, release: 0.5 },
      }).connect(reverb);
      
      const ambientSynth = new Tone.Synth({
        oscillator: { type: 'triangle' },
        envelope: { attack: 2, decay: 1, sustain: 0.3, release: 2 },
      }).connect(reverb);

      // Audio context initialization
      document.addEventListener('click', () => {
        if (!audioContextStarted) {
          Tone.start().then(() => {
            console.log("Enhanced audio system activated");
            audioContextStarted = true;
            gsap.to(audioPrompt, { 
              opacity: 0, 
              scale: 0.5, 
              duration: 0.8, 
              ease: "back.in(1.7)",
              onComplete: () => {
                audioPrompt.style.display = 'none';
                startAmbientSound();
              }
            });
          }).catch(e => console.error("Audio initialization failed:", e));
        }
      }, { once: true });

      function startAmbientSound() {
        // Play subtle ambient tones
        const playAmbient = () => {
          if (audioContextStarted) {
            ambientSynth.triggerAttackRelease(['C4', 'E4', 'G4'][Math.floor(Math.random() * 3)], "2n");
            setTimeout(playAmbient, Math.random() * 5000 + 3000);
          }
        };
        setTimeout(playAmbient, 1000);
      }

      function init() {
        // Enhanced scene setup
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0b0c10, 8, 25);
        
        // Dynamic background
        const bgGeometry = new THREE.SphereGeometry(50, 32, 32);
        const bgMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            colorShift: { value: 0 }
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform float colorShift;
            varying vec2 vUv;
            void main() {
              vec3 color1 = vec3(0.02, 0.05, 0.1);
              vec3 color2 = vec3(0.1, 0.1, 0.3);
              vec3 color3 = vec3(0.05 + colorShift * 0.2, 0.15 + colorShift * 0.3, 0.25 + colorShift * 0.5);
              
              float noise = sin(vUv.x * 10.0 + time * 0.5) * sin(vUv.y * 10.0 + time * 0.3) * 0.5 + 0.5;
              vec3 finalColor = mix(mix(color1, color2, vUv.y), color3, noise);
              
              gl_FragColor = vec4(finalColor, 1.0);
            }
          `,
          side: THREE.BackSide
        });
        const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
        scene.add(bgMesh);

        // Enhanced camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 6;
        camera.position.y = 1;

        // Enhanced renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Enhanced lighting system
        ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);
        
        pointLight = new THREE.PointLight(0x00ffff, 2, 10);
        pointLight.position.set(3, 4, 5);
        pointLight.castShadow = true;
        scene.add(pointLight);
        
  createGroundPlane();
  createEnhancedCan();

        spotLight = new THREE.SpotLight(0xffffff, 1.5);
        spotLight.position.set(0, 8, 0);
        spotLight.target = can;
        spotLight.castShadow = true;
        scene.add(spotLight);

        // Animated rim light (vertical oscillation)
        const rimLight = new THREE.PointLight(0xff00ff, 1.2, 9);
        scene.add(rimLight);
        gsap.to(rimLight.position, { x: 5, duration: 3, yoyo: true, repeat: -1, ease: "sine.inOut" });

        // New subtle orbiting light to produce moving specular highlights
        const orbitLight = new THREE.PointLight(0xff66ff, 0.8, 12);
        orbitLight.position.set(0, 2, 4);
        scene.add(orbitLight);
        gsap.to({}, { // dummy tween driving manual update
          duration: 20,
          repeat: -1,
          onUpdate: function(){
            const t = (this.time()/20) * Math.PI * 2; // normalized cycle
            orbitLight.position.x = Math.cos(t) * 4;
            orbitLight.position.z = Math.sin(t) * 4;
            orbitLight.position.y = 1.5 + Math.sin(t*2)*0.5;
          }
        });

  createEnvironment();

        // Enhanced event listeners
        setupEventListeners();
        
        // Start enhanced bubble system
        setInterval(createEnhancedBubble, 100);
        setInterval(createTrailParticle, 50);
        
        animate();
      }

      function createEnhancedCan() {
        const canGroup = new THREE.Group();
        // --- New: Procedural brushed metal + label + normal map to better match reference ---
        // Brushed metal base texture
        const metalCanvas = document.createElement('canvas');
        metalCanvas.width = 1024; metalCanvas.height = 1024;
        const mctx = metalCanvas.getContext('2d');
        const metalGrad = mctx.createLinearGradient(0, 0, 0, metalCanvas.height);
        metalGrad.addColorStop(0, '#f7f7f9');
        metalGrad.addColorStop(0.3, '#d8dbe0');
        metalGrad.addColorStop(0.7, '#c2c6cc');
        metalGrad.addColorStop(1, '#e6e7ea');
        mctx.fillStyle = metalGrad;
        mctx.fillRect(0, 0, metalCanvas.width, metalCanvas.height);
        // fine vertical strokes for brushed look
        mctx.globalAlpha = 0.35;
        for (let x = 0; x < metalCanvas.width; x+=2) {
          const shade = 200 + Math.sin(x*0.15)*30;
            mctx.fillStyle = `rgb(${shade},${shade},${shade})`;
            mctx.fillRect(x,0,1,metalCanvas.height);
        }
        mctx.globalAlpha = 1;
        const metalTexture = new THREE.CanvasTexture(metalCanvas);
        metalTexture.wrapS = metalTexture.wrapT = THREE.RepeatWrapping;
        metalTexture.anisotropy = 4;

        // Normal map (subtle noise) for micro surface variation
        const normalCanvas = document.createElement('canvas');
        normalCanvas.width = 512; normalCanvas.height = 512;
        const nctx = normalCanvas.getContext('2d');
        const imgData = nctx.createImageData(512,512);
        for (let i=0;i<imgData.data.length;i+=4){
          const v = 120 + Math.random()*30; // base normal-ish bluish
          imgData.data[i] = 128;      // X
          imgData.data[i+1] = 128;    // Y
          imgData.data[i+2] = v;      // Z (blue)
          imgData.data[i+3] = 255;
        }
        nctx.putImageData(imgData,0,0);
        const normalMap = new THREE.CanvasTexture(normalCanvas);
        normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

        // Label wrap texture (pink raspberry / lime theme + center circle)
        const labelCanvas = document.createElement('canvas');
        labelCanvas.width = 2048; labelCanvas.height = 1024; // wide so seam less stretched
        const lctx = labelCanvas.getContext('2d');
        const labelGrad = lctx.createLinearGradient(0,0,0,labelCanvas.height);
        labelGrad.addColorStop(0,'#ff90bf');
        labelGrad.addColorStop(0.5,'#ff2d78');
        labelGrad.addColorStop(1,'#c00052');
        lctx.fillStyle = labelGrad;
        lctx.fillRect(0,0,labelCanvas.width,labelCanvas.height);
        // subtle raspberry seeds pattern
        for (let i=0;i<1200;i++) {
          const rX = Math.random()*labelCanvas.width;
          const rY = Math.random()*labelCanvas.height;
          lctx.fillStyle = `rgba(255,255,255,${Math.random()*0.07})`;
          lctx.beginPath(); lctx.ellipse(rX,rY,Math.random()*6+1,Math.random()*4+1,Math.random()*Math.PI,0,Math.PI*2); lctx.fill();
        }
        // central silver / white disc like reference label
        const cx = labelCanvas.width/2; const cy = labelCanvas.height/2; const radius = 370;
        const discGrad = lctx.createRadialGradient(cx,cy,radius*0.1,cx,cy,radius);
        discGrad.addColorStop(0,'#fbfbfd');
        discGrad.addColorStop(0.55,'#e7e9ed');
        discGrad.addColorStop(1,'#b9bfc7');
        lctx.fillStyle = discGrad;
        lctx.beginPath(); lctx.arc(cx,cy,radius,0,Math.PI*2); lctx.fill();
        // ring stroke
        lctx.lineWidth = 30; lctx.strokeStyle = 'rgba(255,255,255,0.6)';
        lctx.stroke();
        // VOSS text
        lctx.font = 'bold 230px Inter';
        lctx.fillStyle = '#111';
        lctx.textAlign = 'center';
        lctx.textBaseline = 'middle';
        lctx.fillText('V√òSS', cx, cy - 40);
        // flavor text
        lctx.font = '600 70px Inter';
        lctx.fillStyle = '#d40055';
        lctx.fillText('RASPBERRY LIME', cx, cy + 110);
        lctx.font = '400 46px Inter';
        lctx.fillStyle = '#444';
        lctx.fillText('SPARKLING WATER', cx, cy + 180);
        // lime wedges (simple)
        for (let k=0;k<2;k++) {
          const lx = cx + (k===0?-radius*0.95:radius*0.95);
          const ly = cy + 40;
          lctx.save(); lctx.translate(lx,ly); lctx.rotate(k===0?0.25:-0.25);
          lctx.fillStyle = '#d6fca9';
          lctx.beginPath(); lctx.arc(0,0,120,Math.PI*0.2,Math.PI*0.8); lctx.lineTo(0,0); lctx.closePath(); lctx.fill();
          lctx.fillStyle = '#96d84d';
          lctx.beginPath(); lctx.arc(0,0,120,Math.PI*0.32,Math.PI*0.68); lctx.lineTo(0,0); lctx.closePath(); lctx.fill();
          lctx.restore();
        }
        const labelTexture = new THREE.CanvasTexture(labelCanvas);
        labelTexture.anisotropy = 8;

        // Body geometry (metal) separate from label overlay for crispness
        const bodyGeometry = new THREE.CylinderGeometry(0.595, 0.595, 3, 128,1,true);
        const bodyMaterial = new THREE.MeshStandardMaterial({
          map: metalTexture,
            roughness: 0.25,
            metalness: 1.0,
            envMapIntensity: 1.4,
            normalMap: normalMap,
            normalScale: new THREE.Vector2(0.4,0.4)
        });
        const canBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
        canBody.rotation.y = Math.PI; // align seam behind
        canBody.castShadow = true; canBody.receiveShadow = true;

        // Label overlay (slightly larger radius, transparent where no design)
        const labelGeometry = new THREE.CylinderGeometry(0.601,0.601,3,128,1,true);
        const labelMaterial = new THREE.MeshStandardMaterial({
          map: labelTexture,
          transparent: true,
          roughness: 0.35,
          metalness: 0.4,
          emissive: new THREE.Color(0xff2d78).multiplyScalar(0.05),
          emissiveIntensity: 0.6
        });
        const labelMesh = new THREE.Mesh(labelGeometry,labelMaterial);
        labelMesh.castShadow = true;

        // Enhanced can top with rim
        const topGeometry = new THREE.CylinderGeometry(0.6, 0.55, 0.2, 64);
        const topMaterial = new THREE.MeshStandardMaterial({
          color: 0xc0c0c0,
          roughness: 0.1,
          metalness: 1.0
        });
        const canTop = new THREE.Mesh(topGeometry, topMaterial);
        canTop.position.y = 1.6;
        canTop.castShadow = true;

        // Pop tab
        const tabGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 16);
        const tabMaterial = new THREE.MeshStandardMaterial({
          color: 0xe0e0e0,
          roughness: 0.2,
          metalness: 0.8
        });
        const popTab = new THREE.Mesh(tabGeometry, tabMaterial);
        popTab.position.set(0.2, 1.75, 0);
        popTab.castShadow = true;

        // Enhanced can bottom
        const bottomGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.15, 64);
        const bottomMaterial = new THREE.MeshStandardMaterial({
          color: 0xa0a0a0,
          roughness: 0.4,
          metalness: 0.7
        });
  const canBottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
        canBottom.position.y = -1.575;
        canBottom.castShadow = true;

  // Decorative top rim torus
  const rimGeo = new THREE.TorusGeometry(0.58,0.025,12,64);
  const rimMat = new THREE.MeshStandardMaterial({color:0xf0f2f5,metalness:1,roughness:0.15});
  const rim = new THREE.Mesh(rimGeo,rimMat); rim.rotation.x = Math.PI/2; rim.position.y = 1.63; rim.castShadow = true;

  // Bottom rim torus
  const bottomRim = rim.clone(); bottomRim.position.y = -1.63; bottomRim.scale.set(0.98,0.98,0.98);
        
  canGroup.add(canBody, labelMesh, canTop, canBottom, popTab, rim, bottomRim);
        can = canGroup;
        scene.add(can);

  // Add condensation droplets (small glassy spheres)
  createCondensation(canGroup);

  // Create mirrored clone for pseudo reflection on ground plane
  mirrorCan = can.clone(true);
  mirrorCan.traverse(obj=>{ if(obj.material){ obj.material = obj.material.clone(); obj.material.opacity = 0.35; obj.material.transparent = true; obj.material.depthWrite = false; obj.material.side = THREE.DoubleSide; }});
  mirrorCan.scale.y = -1; // flip
  scene.add(mirrorCan);

        // Enhanced can animations
        gsap.to(can.rotation, { y: Math.PI * 2, duration: 20, repeat: -1, ease: "none" });
        gsap.to(can.position, { 
          y: 0.8, 
          duration: 4, 
          ease: "sine.inOut", 
          yoyo: true, 
          repeat: -1 
        });
        gsap.to(can.rotation, {
          x: 0.1,
          z: 0.05,
          duration: 6,
          ease: "sine.inOut",
          yoyo: true,
          repeat: -1
        });
      }

      // New: Polished ground plane with subtle radial falloff
      function createGroundPlane(){
        const planeGroup = new THREE.Group();
        const planeGeo = new THREE.CircleGeometry(12, 128);
        // Custom radial gradient via canvas
        const gradCanvas = document.createElement('canvas'); gradCanvas.width = 512; gradCanvas.height = 512;
        const gctx = gradCanvas.getContext('2d');
        const radial = gctx.createRadialGradient(256,256,30,256,256,250);
        radial.addColorStop(0,'#2b0a25');
        radial.addColorStop(0.55,'#120815');
        radial.addColorStop(1,'#05050a');
        gctx.fillStyle = radial; gctx.fillRect(0,0,512,512);
        const planeTex = new THREE.CanvasTexture(gradCanvas);
        planeTex.anisotropy = 4;
        const planeMat = new THREE.MeshStandardMaterial({ map: planeTex, metalness: 0.85, roughness: 0.18, envMapIntensity: 1.2 });
        const planeMesh = new THREE.Mesh(planeGeo, planeMat);
        planeMesh.rotation.x = -Math.PI/2;
        planeMesh.position.y = -1.6; // just beneath can bottom
        planeMesh.receiveShadow = true;
        planeGroup.add(planeMesh);
        scene.add(planeGroup);
      }

      // --- New helper: creates small shimmering condensation droplets on the can surface ---
      function createCondensation(group){
        const dropletCount = 180;
        const dropletGeo = new THREE.SphereGeometry(0.015, 10, 10);
        for (let i=0;i<dropletCount;i++) {
          const mat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            roughness: 0.05,
            metalness: 0,
            transmission: 1,
            thickness: 0.2,
            ior: 1.33,
            transparent: true,
            opacity: 0.85
          });
          const d = new THREE.Mesh(dropletGeo, mat);
          // random cylindrical coordinates
          const angle = Math.random()*Math.PI*2;
          const y = (Math.random()-0.5)*3; // within body height
          const radius = 0.6 + (Math.random()*0.002); // just above surface
          d.position.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
          d.scale.setScalar(0.5 + Math.random()*1.6);
          group.add(d);
          // subtle shimmer / breathing animation
          gsap.to(d.scale, {x: d.scale.x*1.15, y:d.scale.y*1.15, z:d.scale.z*1.15, duration: 2+Math.random()*3, yoyo:true, repeat:-1, ease:'sine.inOut', delay: Math.random()*2});
          gsap.to(d.position, {y: y + (Math.random()*0.05-0.025), duration: 3+Math.random()*2, yoyo:true, repeat:-1, ease:'sine.inOut', delay: Math.random()*2});
        }
      }

      function createEnvironment() {
        // Replace simple particles with abstract crystalline shards
        const shardCount = 60;
        for(let i=0;i<shardCount;i++){
          const size = Math.random()*0.5 + 0.2;
          const geo = new THREE.IcosahedronGeometry(size,0);
          // Randomly stretch to make shard-like
          geo.scale(1, Math.random()*1.8+0.5, 1);
          const hue = 0.85 + Math.random()*0.1; // magenta / violet
          const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(hue, 0.6, 0.6),
            metalness: 0.6,
            roughness: 0.15,
            emissive: new THREE.Color().setHSL(hue,0.8,0.4),
            emissiveIntensity: 0.35,
            transparent: true,
            opacity: 0.85
          });
          const shard = new THREE.Mesh(geo,mat);
          const radius = 6 + Math.random()*6;
          const angle = Math.random()*Math.PI*2;
          const height = (Math.random()-0.5)*6;
          shard.position.set(Math.cos(angle)*radius, height, Math.sin(angle)*radius);
          shard.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
          scene.add(shard);
          // Orbital animation around Y axis
          const orbitalSpeed = (Math.random()*0.5 + 0.2) * (Math.random()<0.5?1:-1);
          gsap.to(shard.rotation,{ x: shard.rotation.x + Math.PI*2, y: shard.rotation.y + Math.PI*2, duration: 20+Math.random()*20, repeat:-1, ease:'none'});
          // Custom manual update via GSAP ticker (lightweight)
          shard.userData.orbit = {radius, angle, speed: orbitalSpeed, height};
        }
        // Update orbit each frame via animation loop hook
        if(!scene.userData.updateShards){
          scene.userData.updateShards = function(delta){
            scene.traverse(obj=>{
              if(obj.userData.orbit){
                obj.userData.orbit.angle += obj.userData.orbit.speed * delta * 0.1;
                obj.position.x = Math.cos(obj.userData.orbit.angle)*obj.userData.orbit.radius;
                obj.position.z = Math.sin(obj.userData.orbit.angle)*obj.userData.orbit.radius;
              }
            });
          };
        }
      }

      function createEnhancedBubble() {
        const size = Math.random() * 0.08 + 0.02;
        const bubbleGeometry = new THREE.SphereGeometry(size, 16, 16);
        const bubbleMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(0.5 + colorShift, 0.3, 0.9),
          transparent: true,
          opacity: 0.6,
          roughness: 0.1,
          metalness: 0.1,
          envMapIntensity: 2.0
        });
        const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
        
        // Enhanced spawn positions
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 0.4;
        bubble.position.set(
          Math.cos(angle) * radius,
          -1.4,
          Math.sin(angle) * radius
        );
        
        scene.add(bubble);
        bubbles.push(bubble);

        // Play bubble sound
        if (audioContextStarted) {
          const frequency = 200 + size * 2000;
          bubbleSynth.frequency.value = frequency;
          bubbleSynth.triggerAttackRelease("16n", Tone.now() + Math.random() * 0.5);
        }

        // Enhanced bubble animation
        const targetY = 3 + Math.random() * 2;
        const driftX = (Math.random() - 0.5) * 2;
        const driftZ = (Math.random() - 0.5) * 2;
        
        gsap.to(bubble.position, {
          y: targetY,
          x: bubble.position.x + driftX,
          z: bubble.position.z + driftZ,
          duration: (Math.random() * 3 + 2) / timeScale,
          ease: "none",
          onComplete: () => {
            scene.remove(bubble);
            const index = bubbles.indexOf(bubble);
            if (index > -1) bubbles.splice(index, 1);
          }
        });

        // Bubble wobble
        gsap.to(bubble.rotation, {
          x: Math.random() * Math.PI * 2,
          z: Math.random() * Math.PI * 2,
          duration: (Math.random() * 2 + 1) / timeScale,
          repeat: -1,
          yoyo: true,
          ease: "sine.inOut"
        });

        // Size pulsing
        gsap.to(bubble.scale, {
          x: 1 + Math.random() * 0.3,
          y: 1 + Math.random() * 0.3,
          z: 1 + Math.random() * 0.3,
          duration: (Math.random() * 1 + 0.5) / timeScale,
          repeat: -1,
          yoyo: true,
          ease: "sine.inOut"
        });
      }

      function createMegaSplash() {
        if (audioContextStarted) {
          splashSynth.triggerAttackRelease("4n", Tone.now());
          // Add extra bass impact
          const bassOsc = new Tone.Oscillator(60, "sine").toDestination();
          bassOsc.start();
          bassOsc.stop("+0.3");
        }

        // Screen shake effect
        gsap.to(camera.position, {
          x: camera.position.x + (Math.random() - 0.5) * 0.5,
          y: camera.position.y + (Math.random() - 0.5) * 0.5,
          duration: 0.1,
          yoyo: true,
          repeat: 5,
          ease: "power2.out"
        });

        // Create massive particle explosion
        for (let i = 0; i < 800; i++) {
          const particle = createSplashParticle(can.position, true);
          splashes.push(particle);
        }

        // Create shockwave ring
        const ringGeometry = new THREE.RingGeometry(0.1, 0.2, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });
        const shockwave = new THREE.Mesh(ringGeometry, ringMaterial);
        shockwave.position.copy(can.position);
        shockwave.position.y -= 1.2;
        shockwave.rotation.x = Math.PI / 2;
        scene.add(shockwave);

        // Animate shockwave
        gsap.to(shockwave.scale, {
          x: 20,
          y: 20,
          z: 20,
          duration: 2,
          ease: "power2.out"
        });
        gsap.to(shockwave.material, {
          opacity: 0,
          duration: 2,
          ease: "power2.out",
          onComplete: () => scene.remove(shockwave)
        });

        // Flash effect
        const originalIntensity = pointLight.intensity;
        gsap.to(pointLight, {
          intensity: 5,
          duration: 0.1,
          yoyo: true,
          repeat: 1,
          onComplete: () => pointLight.intensity = originalIntensity
        });
      }

      function createSplashParticle(position, isMega = false) {
        const size = Math.random() * (isMega ? 0.1 : 0.05) + 0.01;
        const splashGeometry = new THREE.SphereGeometry(size, 8, 8);
        const splashMaterial = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(0.5 + colorShift + Math.random() * 0.2, 0.8, 0.7),
          transparent: true,
          opacity: 0.9
        });
        const particle = new THREE.Mesh(splashGeometry, splashMaterial);

        const spread = isMega ? 2.0 : 0.8;
        particle.position.set(
          position.x + (Math.random() - 0.5) * spread,
          position.y - 1.2,
          position.z + (Math.random() - 0.5) * spread
        );

        const speed = (Math.random() * (isMega ? 1.0 : 0.5) + 0.2) / timeScale;
        const angle = Math.random() * Math.PI * 2;
        const elevation = Math.random() * Math.PI * 0.3 + Math.PI * 0.1;
        
        particle.velocity = new THREE.Vector3(
          Math.cos(angle) * Math.sin(elevation) * speed,
          Math.cos(elevation) * speed,
          Math.sin(angle) * Math.sin(elevation) * speed
        );

        particle.life = 1.0;
        particle.decay = Math.random() * 0.01 + 0.005;

        scene.add(particle);
        return particle;
      }

      function createTrailParticle() {
        if (bubbles.length === 0) return;
        
        const bubble = bubbles[Math.floor(Math.random() * bubbles.length)];
        const trailGeometry = new THREE.SphereGeometry(0.01, 6, 6);
        const trailMaterial = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(0.6 + colorShift, 0.5, 0.8),
          transparent: true,
          opacity: 0.4
        });
        const trail = new THREE.Mesh(trailGeometry, trailMaterial);
        
        trail.position.copy(bubble.position);
        trail.position.y -= 0.1;
        trail.life = 1.0;
        
        scene.add(trail);
        trails.push(trail);
      }

      function createBubbleBurst() {
        if (audioContextStarted) {
          bubbleSynth.triggerAttackRelease("32n", Tone.now() + Math.random() * 0.1);
        }
        
        // Burst all bubbles simultaneously
        bubbles.forEach(bubble => {
          // Create mini explosion at bubble position
          for (let i = 0; i < 20; i++) {
            const particle = createSplashParticle(bubble.position);
            splashes.push(particle);
          }
          scene.remove(bubble);
        });
        
        bubbles.length = 0; // Clear bubbles array
      }

      function toggleTimeFreeze() {
        timeScale = timeScale === 1 ? 0.1 : 1;
        freezeTimeBtn.textContent = timeScale === 1 ? '‚ñ∂Ô∏è Resume Time' : '‚è∏Ô∏è Freeze Time';
        
        if (audioContextStarted) {
          // Create time warp sound
          const timeWarpSynth = new Tone.Oscillator(timeScale === 1 ? 100 : 800, "sawtooth").toDestination();
          timeWarpSynth.start();
          timeWarpSynth.stop("+0.5");
        }
      }

      function cycleColorShift() {
        colorShift = (colorShift + 0.1) % 1;
        
        // Update existing particles
        [...bubbles, ...splashes, ...trails].forEach(particle => {
          if (particle.material && particle.material.color) {
            particle.material.color.setHSL(0.5 + colorShift, 0.8, 0.7);
          }
        });
        
        // Update background
        scene.children.forEach(child => {
          if (child.material && child.material.uniforms && child.material.uniforms.colorShift) {
            child.material.uniforms.colorShift.value = colorShift;
          }
        });
      }

      // --- Animation Loop and Event Handling ---
      
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function setupEventListeners() {
        // UI Button Listeners
        splashButton.addEventListener('click', createMegaSplash);
        bubbleBurst.addEventListener('click', createBubbleBurst);
        colorShiftBtn.addEventListener('click', cycleColorShift);
        freezeTimeBtn.addEventListener('click', toggleTimeFreeze);

        // Mouse Events for Camera Control
        document.addEventListener('mousedown', (e) => {
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const deltaMove = {
            x: e.clientX - previousMousePosition.x,
            y: e.clientY - previousMousePosition.y
          };
          
          mouseX += deltaMove.x * 0.005;
          mouseY += deltaMove.y * 0.005;

          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('mouseup', () => {
          isDragging = false;
        });

        // Touch Events for Camera Control
        document.addEventListener('touchstart', (e) => {
          isDragging = true;
          const touch = e.touches[0];
          previousMousePosition = { x: touch.clientX, y: touch.clientY };
        });

        document.addEventListener('touchmove', (e) => {
          if (!isDragging) return;
          const touch = e.touches[0];
          const deltaMove = {
            x: touch.clientX - previousMousePosition.x,
            y: touch.clientY - previousMousePosition.y
          };

          mouseX += deltaMove.x * 0.005;
          mouseY += deltaMove.y * 0.005;

          previousMousePosition = { x: touch.clientX, y: touch.clientY };
          e.preventDefault(); // Prevent scrolling
        });

        document.addEventListener('touchend', () => {
          isDragging = false;
        });

        // Window Resize Listener
        window.addEventListener('resize', onWindowResize);
      }
      
      function animate() {
        requestAnimationFrame(animate);
        const timeDelta = performance.now() - lastTime;
        lastTime = performance.now();
        const deltaTime = timeDelta / 1000;

        // Update FPS counter every second
        frameCount++;
        if (performance.now() - lastTime > 1000) {
          const fps = Math.round((frameCount * 1000) / (performance.now() - lastTime));
          fpsCounter.textContent = `FPS: ${fps}`;
          frameCount = 0;
          lastTime = performance.now();
        }

        // Apply camera damping
        camera.position.x += (mouseX - camera.position.x) * DAMPING;
        camera.position.y += (-mouseY - camera.position.y + 1) * DAMPING; // Add a bias for a better starting view
        camera.lookAt(scene.position);

        // Update splash particles
        for (let i = splashes.length - 1; i >= 0; i--) {
          const p = splashes[i];
          p.position.addScaledVector(p.velocity, deltaTime * timeScale);
          p.velocity.y -= 0.8 * timeScale * deltaTime; // Gravity
          p.material.opacity = p.life;
          p.life -= p.decay * timeScale;
          if (p.life <= 0) {
            scene.remove(p);
            splashes.splice(i, 1);
          }
        }

        // Update trail particles
        for (let i = trails.length - 1; i >= 0; i--) {
          const t = trails[i];
          t.material.opacity = t.life;
          t.life -= 0.01 * timeScale;
          if (t.life <= 0) {
            scene.remove(t);
            trails.splice(i, 1);
          }
        }
        
        // Update background time uniform
        scene.children.forEach(child => {
          if (child.material && child.material.uniforms && child.material.uniforms.time) {
            child.material.uniforms.time.value += 0.01 * timeScale;
          }
        });

        // Update UI counters
        document.getElementById('bubble-count').textContent = bubbles.length;
        document.getElementById('particle-count').textContent = splashes.length;
        document.getElementById('effect-count').textContent = trails.length;

        // Mirror can update (pseudo reflection)
        if(mirrorCan){
          const planeY = -1.6;
          mirrorCan.position.x = can.position.x;
          mirrorCan.position.z = can.position.z;
            mirrorCan.position.y = 2*planeY - can.position.y; // reflect across plane
          mirrorCan.rotation.copy(can.rotation);
        }

        // Update shard orbits
        if(scene.userData.updateShards){ scene.userData.updateShards(deltaTime); }

        renderer.render(scene, camera);
      }
      
      window.onload = function () {
        init();
      };
    });
  </script>
</body>
</html>
